# практическое задание 13
## Шишков А.Д. ЭФМО-02-22
## Тема
Профилирование Go-приложения (pprof). Измерение времени работы функций 
## Цели
-	Научиться подключать и использовать профилировщик pprof для анализа CPU, памяти, блокировок и горутин.
-	Освоить базовые техники измерения времени выполнения функций (ручные таймеры, бенчмарки).
-	Научиться читать отчёты go tool pprof, строить графы вызовов и находить “узкие места”.
- Сформировать практические навыки оптимизации кода на основании метрик.


## Структура проекта

```text
pprof-lab/
 ├─ cmd/
 │   └─ api/
 │       └─ main.go       
 ├─ internal/
 │   └─ work/
 │       ├─ slow.go          
 │       ├─ timer.go         
 │       ├─ slow_test.go     
 │       └─ locks.go         
 └─ go.mod

```
## Краткое описание стенда 
В качестве стенда использовалось серверное приложение на языке Go, реализующее HTTP-сервер с обработчиком /work, выполняющим вычисление чисел Фибоначчи. Для создания нагрузки используется внешний клиент, отправляющий HTTP-запросы к серверу. Профилирование выполняется с помощью встроенного пакета net/http/pprof.
## Версия Go:
go1.22 (linux/amd64)

### Запуск проекта
1. Склонировать репозиторий и перейти в папку проекта:
   ```bash
   git clone https://github.com/Alex171228/Pz13
   cd pz13
    ```
2. Установите зависимости
   ```bash
   go mod tidy
   ```
3. Запуск сервера
   ```bash
   go run ./cmd/api
   ```

Сервер будет слушать порт `:8080`: 

- Эндпоинт нагрузки: `http://109.237.98.39:8080/work`
- Профили pprof: `http://109.237.98.39:8080/debug/pprof/`

## Генерация нагрузки
### Снимки экрана/вывод команд с CPU-профилем: top, graph/web (до оптимизации).
Для анализа загрузки процессора был использован встроенный профайлер Go pprof.
Профилирование выполнялось для версии приложения до оптимизации, в которой используется рекурсивная реализация вычисления чисел Фибоначчи (work.Fib).
CPU-профиль снимался с удалённого сервера с использованием команды:
```bash
go tool pprof -http=:9999 http://<IP_СЕРВЕРА>:8080/debug/pprof/profile?seconds=30
```

<img width="624" height="238" alt="image" src="https://github.com/user-attachments/assets/477991c4-4bb7-45ff-9267-7e8a2aca46d6" /> 

Во время сбора профиля (30 секунд) на сервер создавалась нагрузка путём отправки HTTP-запросов к эндпоинту /work.
На вкладке Graph (Web) отображается граф вызовов функций, показывающий путь выполнения программы от HTTP-обработчика до наиболее ресурсоёмкой функции.
Анализ графа показал, что:
- HTTP-инфраструктура (ServeHTTP) не оказывает существенного влияния на производительность;

- основная нагрузка сосредоточена в функции work.Fib;

- функция work.Fib является конечной точкой, в которой происходит основное потребление CPU.


<img width="372" height="861" alt="image" src="https://github.com/user-attachments/assets/5a6b0d49-ee66-44de-b699-cb08efe69bc2" /> 

На основании CPU-профилирования сделан вывод, что рекурсивная реализация вычисления чисел Фибоначчи является основным источником нагрузки на процессор. Это обосновывает необходимость оптимизации алгоритма и перехода к более эффективной реализации.

## Heap-профиль (краткий анализ, какие функции аллоцируют память).

<img width="428" height="770" alt="image" src="https://github.com/user-attachments/assets/c38cff1a-4d80-41b2-a0f5-f0788d86e11b" /> 

Для анализа использования оперативной памяти был снят Heap-профиль приложения с помощью встроенного инструмента профилирования Go pprof.
Heap-профиль получен командой:

  ```bash
  go tool pprof -http=:9998 http://<IP_СЕРВЕРА>:8080/debug/pprof/heap
  ```
### Анализ Heap-профиля
В результате анализа Heap-профиля установлено, что все значимые аллокации памяти выполняются в стандартной библиотеке Go, в частности в пакете compress/flate.
Наибольший объём выделяемой памяти приходится на функцию:
  ```bash
  flate.newDeflateFast
  ```

которая потребляет порядка 583 КБ памяти (100% всех аллокаций). Данная функция используется HTTP-сервером для инициализации механизмов сжатия и буферизации при записи HTTP-ответов.

Пользовательские функции приложения, включая work.Fib и work.FibFast, в Heap-профиле отсутствуют, что свидетельствует об отсутствии динамических аллокаций памяти в пользовательском коде. Это подтверждается нулевыми значениями показателей B/op и allocs/op в результатах бенчмарков.
### Вывод по Heap-профилю
Таким образом, Heap-профиль показал, что приложение корректно использует оперативную память, не содержит утечек и избыточных аллокаций, а выявленные выделения памяти носят служебный характер и связаны исключительно с работой стандартной HTTP-инфраструктуры Go.

## Логи ручных таймеров и результаты бенчмарков -bench -benchmem (до/после).
В обработчике /work используется ручной таймер:
  ```bash
  defer work.TimeIt(fmt.Sprintf("Fib(%d)", n))()
  ```
Он выводит в лог сервера время выполнения одного запроса.
До оптимизации:

<img width="574" height="873" alt="image" src="https://github.com/user-attachments/assets/570fbca8-204c-46a9-af9f-1b06537ede2a" /> 

После оптимизации:

<img width="499" height="868" alt="image" src="https://github.com/user-attachments/assets/29836691-da53-4f01-8e87-cbbe51a52aa1" /> 

Бенчмарк до и после оптимизации:

<img width="1188" height="54" alt="image" src="https://github.com/user-attachments/assets/c5be6ad0-7496-49f3-b261-2d407d52880f" /> 

