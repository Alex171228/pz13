# практическое задание 13
## Шишков А.Д. ЭФМО-02-22
## Тема
Профилирование Go-приложения (pprof). Измерение времени работы функций 
## Цели
-	Научиться подключать и использовать профилировщик pprof для анализа CPU, памяти, блокировок и горутин.
-	Освоить базовые техники измерения времени выполнения функций (ручные таймеры, бенчмарки).
-	Научиться читать отчёты go tool pprof, строить графы вызовов и находить “узкие места”.
- Сформировать практические навыки оптимизации кода на основании метрик.


## Структура проекта

```text
pprof-lab/
 ├─ cmd/
 │   └─ api/
 │       └─ main.go       
 ├─ internal/
 │   └─ work/
 │       ├─ slow.go          
 │       ├─ timer.go         
 │       ├─ slow_test.go     
 │       └─ locks.go         
 └─ go.mod

```
## Краткое описание стенда 
В качестве стенда использовалось серверное приложение на языке Go, реализующее HTTP-сервер с обработчиком /work, выполняющим вычисление чисел Фибоначчи. Для создания нагрузки используется внешний клиент, отправляющий HTTP-запросы к серверу. Профилирование выполняется с помощью встроенного пакета net/http/pprof.
## Версия Go:
go1.22 (linux/amd64)

### Запуск проекта
1. Склонировать репозиторий и перейти в папку проекта:
   ```bash
   git clone https://github.com/Alex171228/Pz13
   cd pz13
    ```
2. Установите зависимости
   ```bash
   go mod tidy
   ```
3. Запуск сервера
   ```bash
   go run ./cmd/api
   ```

Сервер будет слушать порт `:8080`: 

- Эндпоинт нагрузки: `http://109.237.98.39:8080/work`
- Профили pprof: `http://109.237.98.39:8080/debug/pprof/`

## Генерация нагрузки
### Снимки экрана/вывод команд с CPU-профилем: top, graph/web (до оптимизации).
Для анализа загрузки процессора был использован встроенный профайлер Go pprof.
Профилирование выполнялось для версии приложения до оптимизации, в которой используется рекурсивная реализация вычисления чисел Фибоначчи (work.Fib).
CPU-профиль снимался с удалённого сервера с использованием команды:
```bash
go tool pprof -http=:9999 http://<IP_СЕРВЕРА>:8080/debug/pprof/profile?seconds=30
```

<img width="624" height="238" alt="image" src="https://github.com/user-attachments/assets/477991c4-4bb7-45ff-9267-7e8a2aca46d6" /> 

Во время сбора профиля (30 секунд) на сервер создавалась нагрузка путём отправки HTTP-запросов к эндпоинту /work.
На вкладке Graph (Web) отображается граф вызовов функций, показывающий путь выполнения программы от HTTP-обработчика до наиболее ресурсоёмкой функции.
Анализ графа показал, что:
- HTTP-инфраструктура (ServeHTTP) не оказывает существенного влияния на производительность;

- основная нагрузка сосредоточена в функции work.Fib;

- функция work.Fib является конечной точкой, в которой происходит основное потребление CPU.


<img width="372" height="861" alt="image" src="https://github.com/user-attachments/assets/5a6b0d49-ee66-44de-b699-cb08efe69bc2" /> 

```bash
hey -n 200 -c 8 http://localhost:8080/work
```

Или скриптом на `curl` в цикле.

## Получение профилей

- Индекс pprof: `http://localhost:8080/debug/pprof/`
- CPU (30 секунд):

  ```bash
  go tool pprof -http=:9999 http://localhost:8080/debug/pprof/profile?seconds=30
  ```

- Heap:

  ```bash
  go tool pprof -http=:9998 http://localhost:8080/debug/pprof/heap
  ```

## Бенчмарки

```bash
go test -bench=. -benchmem ./...
```

Сравните `BenchmarkFib` и `BenchmarkFibFast` по метрикам:
- ns/op — время на операцию
- B/op — байт на операцию
- allocs/op — количество аллокаций на операцию
