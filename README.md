# практическое задание 13
## Шишков А.Д. ЭФМО-02-22
## Тема
Профилирование Go-приложения (pprof). Измерение времени работы функций 
## Цели
-	Научиться подключать и использовать профилировщик pprof для анализа CPU, памяти, блокировок и горутин.
-	Освоить базовые техники измерения времени выполнения функций (ручные таймеры, бенчмарки).
-	Научиться читать отчёты go tool pprof, строить графы вызовов и находить “узкие места”.
- Сформировать практические навыки оптимизации кода на основании метрик.


## Структура проекта

<img width="301" height="268" alt="image" src="https://github.com/user-attachments/assets/5ce305cf-4cce-4645-b568-6a6ac40f69f4" /> 

## Краткое описание стенда 
В качестве стенда использовалось серверное приложение на языке Go, реализующее HTTP-сервер с обработчиком /work, выполняющим вычисление чисел Фибоначчи. Для создания нагрузки используется внешний клиент, отправляющий HTTP-запросы к серверу. Профилирование выполняется с помощью встроенного пакета net/http/pprof.
## Версия Go:
go1.22 (linux/amd64)

### Запуск проекта
1. Склонировать репозиторий и перейти в папку проекта:
   ```bash
   git clone https://github.com/Alex171228/Pz13
   cd pz13
    ```
2. Установите зависимости
   ```bash
   go mod tidy
   ```
3. Запуск сервера
   ```bash
   go run ./cmd/api
   ```

Сервер будет слушать порт `:8080`: 

- Эндпоинт нагрузки: `http://109.237.98.39:8080/work`
- Профили pprof: `http://109.237.98.39:8080/debug/pprof/`

## Генерация нагрузки
### Снимки экрана/вывод команд с CPU-профилем: top, graph/web (до оптимизации).
Для анализа загрузки процессора был использован встроенный профайлер Go pprof.
Профилирование выполнялось для версии приложения до оптимизации, в которой используется рекурсивная реализация вычисления чисел Фибоначчи (work.Fib).
```go
func Fib(n int) int {
    if n < 2 {
        return n
    }
    return Fib(n-1) + Fib(n-2)
}
```
CPU-профиль снимался с удалённого сервера с использованием команды:
```bash
go tool pprof -http=:9999 http://<IP_СЕРВЕРА>:8080/debug/pprof/profile?seconds=30
```

<img width="624" height="238" alt="image" src="https://github.com/user-attachments/assets/477991c4-4bb7-45ff-9267-7e8a2aca46d6" /> 

Во время сбора профиля (30 секунд) на сервер создавалась нагрузка путём отправки HTTP-запросов к эндпоинту /work.
На вкладке Graph (Web) отображается граф вызовов функций, показывающий путь выполнения программы от HTTP-обработчика до наиболее ресурсоёмкой функции.
Анализ графа показал, что:
- HTTP-инфраструктура (ServeHTTP) не оказывает существенного влияния на производительность;

- основная нагрузка сосредоточена в функции work.Fib;

- функция work.Fib является конечной точкой, в которой происходит основное потребление CPU.


<img width="372" height="861" alt="image" src="https://github.com/user-attachments/assets/5a6b0d49-ee66-44de-b699-cb08efe69bc2" /> 

На основании CPU-профилирования сделан вывод, что рекурсивная реализация вычисления чисел Фибоначчи является основным источником нагрузки на процессор. Это обосновывает необходимость оптимизации алгоритма и перехода к более эффективной реализации.

## Heap-профиль (краткий анализ, какие функции аллоцируют память).

<img width="428" height="770" alt="image" src="https://github.com/user-attachments/assets/c38cff1a-4d80-41b2-a0f5-f0788d86e11b" /> 

Для анализа использования оперативной памяти был снят Heap-профиль приложения с помощью встроенного инструмента профилирования Go pprof.
Heap-профиль получен командой:

  ```bash
  go tool pprof -http=:9998 http://<IP_СЕРВЕРА>:8080/debug/pprof/heap
  ```
### Анализ Heap-профиля
В результате анализа Heap-профиля установлено, что все значимые аллокации памяти выполняются в стандартной библиотеке Go, в частности в пакете compress/flate.
Наибольший объём выделяемой памяти приходится на функцию:
  ```bash
  flate.newDeflateFast
  ```
которая потребляет порядка 583 КБ памяти (100% всех аллокаций). Данная функция используется HTTP-сервером для инициализации механизмов сжатия и буферизации при записи HTTP-ответов.
Пользовательские функции приложения, включая work.Fib и work.FibFast, в Heap-профиле отсутствуют, что свидетельствует об отсутствии динамических аллокаций памяти в пользовательском коде. Это подтверждается нулевыми значениями показателей B/op и allocs/op в результатах бенчмарков.
### Вывод по Heap-профилю
Таким образом, Heap-профиль показал, что приложение корректно использует оперативную память, не содержит утечек и избыточных аллокаций, а выявленные выделения памяти носят служебный характер и связаны исключительно с работой стандартной HTTP-инфраструктуры Go.

## Логи ручных таймеров и результаты бенчмарков -bench -benchmem (до/после).
В обработчике /work используется ручной таймер:
  ```bash
  defer work.TimeIt(fmt.Sprintf("Fib(%d)", n))()
  ```
Он выводит в лог сервера время выполнения одного запроса.
До оптимизации:

<img width="574" height="873" alt="image" src="https://github.com/user-attachments/assets/570fbca8-204c-46a9-af9f-1b06537ede2a" /> 

После оптимизации:

<img width="499" height="868" alt="image" src="https://github.com/user-attachments/assets/29836691-da53-4f01-8e87-cbbe51a52aa1" /> 

Бенчмарк до и после оптимизации:

<img width="1188" height="54" alt="image" src="https://github.com/user-attachments/assets/c5be6ad0-7496-49f3-b261-2d407d52880f" /> 

## Описание внесённых изменений 
В ходе анализа CPU-профиля приложения было выявлено узкое место в функции work.Fib, реализующей вычисление чисел Фибоначчи рекурсивным способом. Данная функция потребляла порядка 99% процессорного времени, что свидетельствовало о неэффективности используемого алгоритма.
### Выполненные изменения
Для устранения выявленного узкого места была выполнена следующая оптимизация:
рекурсивная реализация вычисления чисел Фибоначчи (Fib) была заменена на итеративную реализацию (FibFast);
новая реализация имеет линейную временную сложность O(n) вместо экспоненциальной O(2ⁿ), характерной для рекурсивного алгоритма;
оптимизация не затрагивает интерфейс функции и не изменяет бизнес-логику приложения, а только улучшает производительность вычислений.
  ```go
func FibFast(n int) int {
    if n < 2 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
  ```
### Причины оптимизации
Оптимизация была выполнена по следующим причинам:
CPU-профиль однозначно указывал на функцию work.Fib как основной источник нагрузки;
рекурсивный алгоритм создаёт большое количество повторяющихся вычислений;
итеративная реализация позволяет существенно сократить время выполнения без увеличения потребления памяти.
### Результат оптимизации
На основании результатов бенчмарков:
- время выполнения рекурсивной реализации Fib составляет ≈ 3 161 228 нс (≈ 3.16 мс);
- время выполнения оптимизированной реализации FibFast составляет ≈ 7.923 нс.
Расчёт ускорения:
3 161 228 ns / 7.923 ns ≈ 399 000
Таким образом, оптимизированная версия алгоритма выполняется примерно в 4×10⁵ раз быстрее по сравнению с исходной реализацией.
После внесения изменений и повторного профилирования было установлено, что:
функция work.Fib перестала быть узким местом и отсутствует среди наиболее ресурсоёмких функций;
общее потребление CPU значительно сократилось;
основное время выполнения сместилось на операции ввода-вывода (запись HTTP-ответа), что является ожидаемым поведением.
## Выводы
В ходе выполнения практической работы было проведено профилирование серверного приложения на языке Go с использованием инструмента pprof. Анализ CPU-профиля показал, что основное узкое место приложения находилось в функции work.Fib, реализующей рекурсивный алгоритм вычисления чисел Фибоначчи. Данная функция потребляла порядка 99% процессорного времени, что приводило к значительным задержкам при обработке HTTP-запросов.
Выполненная оптимизация заключалась в замене рекурсивной реализации на итеративную (FibFast), что позволило существенно снизить вычислительную сложность алгоритма. В результате повторного профилирования было установлено, что функция work.Fib перестала быть узким местом, а основная нагрузка сместилась на операции ввода-вывода, связанные с формированием и отправкой HTTP-ответа. Это является ожидаемым и корректным поведением для оптимизированного сервера.
Результаты ручных замеров времени и бенчмарков go test -bench -benchmem подтвердили эффективность оптимизации: время выполнения операций сократилось с миллисекунд до наносекунд, при этом аллокации памяти отсутствуют. Heap-профиль показал, что пользовательский код не выполняет значимых аллокаций, а выявленные выделения памяти относятся к стандартной библиотеке Go и не свидетельствуют о наличии утечек.
В дальнейшем, при необходимости дальнейшего повышения производительности, можно рассмотреть оптимизацию сетевого ввода-вывода, настройку параметров HTTP-сервера, использование кэширования результатов вычислений, а также проведение нагрузочного тестирования с большим количеством параллельных запросов.
